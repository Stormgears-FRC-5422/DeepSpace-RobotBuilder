// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5422.Minimec.commands.Drive;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc5422.Minimec.Robot;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.GenericHID.RumbleType;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc5422.Minimec.subsystems.PixyVision;
import org.usfirst.frc5422.Minimec.subsystems.NavX;
import org.usfirst.frc5422.Minimec.subsystems.TapeAlign;
import org.usfirst.frc5422.Minimec.subsystems.PixyVision.DockSelection;
import org.usfirst.frc5422.Minimec.subsystems.PixyVision.VisionMode;
import org.usfirst.frc5422.utils.StatusLight;
import org.usfirst.frc5422.utils.StormProp;
import org.usfirst.frc5422.utils.DeepSpaceTypes.DockTarget;

import javax.swing.plaf.synth.SynthToolTipUI;
/**
 *
 */
public class AutoDockApproach extends Command {

    private Joystick joy;
    private double m_target_distance = 7.7; // Stop point when approaching the dock.  Not a real distance
    private double m_max_dist = 40; // Point at which to start controlling robot forward speed
    private Boolean m_rumble_left = false;  // State of joystick rumble setting
    private final double m_max_contact_forward_speed = 0.05; // Max forward speed control when gripper in contact
    private Boolean m_pause = true; // State when PID control of drivetrain is suspended
    private Boolean m_ship_mode = true;  // alignment for cargo ship only (90 degress), otherwise uses 30 degree rocket alignment
    private PixyVision.DockSelection m_vision_select = PixyVision.DockSelection.MIDDLE;   // Vision system selection of dock
    private DockTarget m_dock_target = DockTarget.SHIP_MIDDLE; // Desired dock to this command to approach
    private Boolean m_tape_detected = false; // State of floor tape existance
    private Boolean m_tape_system_enabled = false; // State of floor tape PID loop.  Disabled if no tape seen to save processing

    private final double m_approach_speed; // Constant close-in speed
    private final double m_approach_cutover_speed; // vision controlled speed value at which we cut over to m_approach_speed
    private final double m_approach_kp; // P constant like term for approach speed control
    private Boolean m_finish_on_tape = false;
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public AutoDockApproach() {
        m_approach_speed = StormProp.getNumber("dockApproachSpeed",.2);
        m_approach_cutover_speed = StormProp.getNumber("dockApproachCutoverSpeed",.3);
        m_approach_kp = StormProp.getNumber("dockApproachKP",2.0);


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.drive);
        m_ship_mode = true;
    }

    // Constructor that accepts dock target as argument
    public AutoDockApproach(DockTarget target){
        this();
        m_dock_target = target;
        if (target == DockTarget.SHIP_LEFT) {
            m_vision_select = PixyVision.DockSelection.LEFT;
            m_ship_mode = true;
            if(Robot.useStatusLights) Robot.setStatusLight(StatusLight.Vision, 1);
        }
        else if (target == DockTarget.SHIP_MIDDLE) {
            m_vision_select = PixyVision.DockSelection.MIDDLE;
            m_ship_mode = true;
            if(Robot.useStatusLights) Robot.setStatusLight(StatusLight.Vision, 1);
        }
        else if (target == DockTarget.SHIP_RIGHT) {
            m_vision_select = PixyVision.DockSelection.RIGHT;
            m_ship_mode = true;
            if(Robot.useStatusLights) Robot.setStatusLight(StatusLight.Vision, 1);
        }
        else if (target == DockTarget.ROCKET_LEFT) {
            m_vision_select = PixyVision.DockSelection.MIDDLE;
            m_ship_mode = false;
            if(Robot.useStatusLights) Robot.setStatusLight(StatusLight.Vision, 2);
        }
        else if (target == DockTarget.ROCKET_RIGHT) {
            m_vision_select = PixyVision.DockSelection.MIDDLE;
            m_ship_mode = false;
            if(Robot.useStatusLights) Robot.setStatusLight(StatusLight.Vision, 2);
        }


    }

    // Constructor that accepts dock target as argument
    public AutoDockApproach(DockTarget target, Boolean finishOnTape){
        this(target);
        m_dock_target = target;
	    m_finish_on_tape = finishOnTape;
    }
	
	// Called just before this Command runs the first time
    @Override
    protected void initialize() {
        if (Robot.useDrive) {
            joy = Robot.oi.getJoystick();
        }
        m_pause = true;
        set_targets();
        Robot.drive.setBrakeMode();
        Robot.pixyVision.set_strafe_mode();
        Robot.pixyVision.enable(VisionMode.DOCK);
    }

    // Based on current heading and what our desired dock is, set the correct PID targets
    // for vision and gyro
    private void set_targets() {
        if (Robot.navX.is_enabled()) {
            Robot.navX.setNavxTarget(m_dock_target);
        }
        else{
            Robot.navX.enable(m_dock_target);
        }
        Robot.pixyVision.changeDockMode(m_vision_select);
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        if (Robot.useDrive) {
            double distance = Robot.pixyVision.getDockDistance();


            double joy_vals[] = Robot.oi.getJoyXYZ(joy);

            double x = joy_vals[0];
            double y = joy_vals[1];
            double z = joy_vals[2];


            // User must hold button to engage PID control
            if (joy.getRawButton(5) == true) {
                // Button 5 will enable PID input to drive
                if (m_pause) set_targets(); // reset pid targets when first entering PID control
                m_pause = false;

                // only look for tape in this mode to prevent false alarms
                if (Robot.tapeAlignSys.tapeDetected()){
                    m_tape_detected = true;
                } else {
                    m_tape_detected = false;
                }   

            // If the gripper has made contact, stop forward motion, vibrate controller
                if (Robot.valveControl.getHatchProxSensorReady()) {
                    if (y > m_max_contact_forward_speed) y = m_max_contact_forward_speed;
                    set_rumble(true);
                } else {
                    set_rumble(false);
                }  

                if(m_tape_detected) {
                    if (!m_tape_system_enabled) {
                        Robot.tapeAlignSys.enable();  // Don't call this every cycle
                        m_tape_system_enabled = true;
                    }
                    x += Robot.tapeAlignSys.get_pid_output();  // tape system controls strafing
                }
                else {
                    if (m_tape_system_enabled) Robot.tapeAlignSys.disable(); 
                    m_tape_system_enabled = false;
                    x += Robot.pixyVision.get_pid_output(); // vision controls strafing
                }
                z += Robot.navX.get_pid_output();  // NavX controls turning
            } else {
                Robot.pixyVision.clearLastTracked(); // forget what dock pair we were tracking
                Robot.tapeAlignSys.disable();  
                m_tape_system_enabled = false;
                m_pause = true;
            }
            if (z > 1.0) z = 1.0;
            if (z < -1.0) z = -1.0;

            if (x > 1.0) x = 1.0;
            if (x < -1.0) x = -1.0;


            if (distance > 0 && distance < (m_target_distance + m_max_dist)) {
                SmartDashboard.putNumber("PixyVisionDistance", distance);
                // Modulate driver forward input
                if (y > 0) {
                    if (m_pause) {
                        // if paused, limit driver move forward to .2 when close
                        if (m_target_distance < m_target_distance/2) {
                            if (y > .1) y = .1;
                        }
                    }
                    else {
                        y = m_approach_kp * y * (distance - m_target_distance) / m_max_dist;
                        if (y > .5) y = .5; // Max approach speed

                        if (y > 0 && y < m_approach_cutover_speed) y = m_approach_speed; // max approach speed
                    }
                } 
            } 

            Robot.drive.driveArcade(x, y, z);

            SmartDashboard.putNumber("PixyVisionPidOut", Robot.pixyVision.get_pid_output());
        }
    }

    private void set_rumble(Boolean enable) {
        if (enable && !m_rumble_left) {
            joy.setRumble(RumbleType.kLeftRumble, .5);
            m_rumble_left = true;
        }
        if (!enable && m_rumble_left) {
            joy.setRumble(RumbleType.kLeftRumble, 0);
            m_rumble_left = false;
        }
    }
    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
	    if (m_finish_on_tape && m_tape_detected) {
	        return true;
    	} else {
	        return false;
	    }
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        Robot.navX.disable();
        Robot.pixyVision.disable();
        m_pause = true;
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
        Robot.navX.disable();
        Robot.pixyVision.disable();
    }
}
