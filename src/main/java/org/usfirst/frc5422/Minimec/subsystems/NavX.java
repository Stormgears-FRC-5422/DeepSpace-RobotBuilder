/*----------------------------------------------------------------------------*/
/* Copyright (c) 2018 FIRST. All Rights Reserved.                             */
/* Open Source Software - may be modified and shared by FRC teams. The code   */
/* must be accompanied by the FIRST BSD license file in the root directory of */
/* the project.                                                               */
/*----------------------------------------------------------------------------*/

package org.usfirst.frc5422.Minimec.subsystems;

import edu.wpi.first.wpilibj.command.PIDSubsystem;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.shuffleboard.Shuffleboard;
import edu.wpi.first.wpilibj.shuffleboard.ShuffleboardTab;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import org.usfirst.frc5422.utils.StormProp;
import edu.wpi.first.networktables.NetworkTableEntry;
import com.kauailabs.navx.frc.AHRS;
import edu.wpi.first.wpilibj.SerialPort;

/**
 *
 */
public class NavX extends PIDSubsystem {
    public enum AngleUnit {
            Degrees,Radians;
    }   
    private double m_pid_out;
    private ShuffleboardTab m_debug_tab;
    private  AHRS m_ahrs;
    private double m_heading_offset;
    private boolean m_calibrated;
    private double m_desired_angle;
    private NetworkTableEntry m_raw_entry;
    private NetworkTableEntry m_ena_entry;
    private boolean useShuffleboard = StormProp.getBoolean("debugconfig", false);

    private ShuffleboardTab match_tab;
    private NetworkTableEntry orientation_entry;

    // Leave setpoint at 0. We will calculate relative position to target
    // so that we can always set input to 0 when we don't have an object
    // to keep the PID from reacting.

    // Initialize your subsystem here
    public NavX() {
        super("NavX", .03, 0.0, .04, 0.0, .02);
        getPIDController().setContinuous(false);
        getPIDController().setName("NavX", "PIDSubsystem Controller");
        LiveWindow.add(getPIDController());
        getPIDController().setAbsoluteTolerance(2);   // FIXME property 
        getPIDController().setOutputRange(-0.35, 0.35);  // FIXME property 
	    m_ahrs = new AHRS(SerialPort.Port.kUSB);
	
        // Debug data
        if(useShuffleboard){
        m_debug_tab = Shuffleboard.getTab("NavXDebug");
        m_raw_entry = m_debug_tab.add("Sensor Value", 0).getEntry();
        m_ena_entry = m_debug_tab.add("Enabled", false).getEntry();
        SmartDashboard.getNumber("NavX PID Value", get_pid_output());
        SmartDashboard.putData("NavX", m_ahrs);}

        match_tab = Shuffleboard.getTab("Match Tab");
        orientation_entry = match_tab.add("Orientation", 0).getEntry();
    
        m_ahrs.zeroYaw();
    }


    @Override
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }

    public Boolean is_enabled() {
        return(getPIDController().isEnabled());
    }

    public void enable(double req_heading) {
        set_gyro_target(req_heading);
        getPIDController().enable();
        if (useShuffleboard) {
        SmartDashboard.putNumber("NavX Desired Heading", req_heading);
        SmartDashboard.putString("NavX Heading Subsystem", "ENABLED");
        m_ena_entry.setBoolean(true);}
    }

    // find closest angle in steps of angle_step
    public double align_to_closest(double heading,double angle_step) {
        heading += angle_step/2;
        heading = heading % 360;
        int num_steps = (int) (360/angle_step);
        int target_step = (int) (heading / angle_step);
        return(360 * ((1.0 * target_step)/num_steps));
    }

    public double align_to_closest(double angle_step) {
        return align_to_closest(getHeading(),angle_step);
    }


    public void set_gyro_target(double req_heading) {
        double cur_angle = m_ahrs.getAngle();

        double delta_heading = (req_heading - getYaw()) % 360;
        SmartDashboard.putNumber("NavX Delta Heading", delta_heading);
        // Determine shortest direction
        if (Math.abs(delta_heading) > 180 ) {
            delta_heading = (delta_heading - 360) % 360;
        }

        m_desired_angle = delta_heading + cur_angle;
        getPIDController().setSetpoint(m_desired_angle);
    }

    public void disable() {
        getPIDController().disable();
        SmartDashboard.putString("NavX Heading Subsystem", "DISABLED");
        if (useShuffleboard) m_ena_entry.setBoolean(false);
    }

    public double getHeading() {
    	return getHeading(AngleUnit.Degrees,true);
    }

    public double getYaw() {
        // -180 to +180
        return m_ahrs.getYaw();
    }

    public double getHeading(AngleUnit unit,Boolean wrap) {
        //  0-360
        double yaw = getYaw();
        if (wrap) {
            if (yaw < 0) yaw += 360;
        }

        if (unit == AngleUnit.Radians) {
            yaw = Math.toRadians(yaw); // radians
        }
        return yaw;
    }

    public void calibrate() {
        m_ahrs.zeroYaw();
	    m_calibrated = true;
    }
    
    @Override
    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;
        double angle = m_ahrs.getAngle();
        if (useShuffleboard) {
            SmartDashboard.putNumber("Heading", getHeading());
            m_raw_entry.setDouble(angle);
        }

        return(angle);
    }

    public double get_pid_output() {
        return(m_pid_out);
    }

    @Override
    protected void usePIDOutput(double output) {
        // Use output to drive your system, like a motor
        // e.g. yourMotor.set(output);
        m_pid_out = output;  
    }

    public void periodic(){
        orientation_entry.setDouble(getHeading());
    }
}

